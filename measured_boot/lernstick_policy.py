import typing
import re

from . import policies
from . import tests
from .policies import RefState


# Relative simple UEFI event log policy based on the Example policy provided by Keylime
# Copy into keylime.elchecking



class LernstickPolicy(policies.Policy):
    relevant_pcrs = frozenset(list(range(10)) + [14])

    # Regex that should cover all the valid kernel commandline options in our configuration
    """
    linux $DEFAULT_KERNEL $DEFAULT_APPEND locales=$LOCALES keyboard-layouts=$KEYBOARD desktop=$DESKTOP $LIVE_MEDIA $PERSISTENCE_MEDIA $PERSISTENCE $SWAP $QUIET custom_options $CUSTOM_OPTIONS
    initrd $DEFAULT_INITRD
    """
    kernel_cmd_regex = re.compile("/live/vmlinuz ")

    def get_relevant_pcrs(self) -> typing.FrozenSet[int]:
            return self.relevant_pcrs

    def refstate_to_test(self, refstate: RefState) -> tests.Test:
        # If emtpy refstate is supplied we default to accept all for testing
        if len(refstate.items()) == 0:
            return tests.AcceptAll()

        dispatcher = tests.Dispatcher(('PCRIndex', 'EventType'))
        vd = tests.VariableDispatch()

        # This event does not have an impact and does not extend a PCR
        dispatcher.set((0, 'EV_NO_ACTION'), tests.AcceptAll())

        # Firmware specific numbers and binaries. We currently accept all,
        # but in the future can extract this information from the submitted event log.
        dispatcher.set((0, 'EV_S_CRTM_VERSION'), tests.AcceptAll())
        dispatcher.set((0, 'EV_EFI_PLATFORM_FIRMWARE_BLOB'), tests.AcceptAll())

        # Check if SecureBoot is enabled
        dispatcher.set((7, 'EV_EFI_VARIABLE_DRIVER_CONFIG'), vd)
        vd.set('61dfe48b-ca93-d211-aa0d-00e098032b8c', 'SecureBoot',
               tests.FieldTest('Enabled', tests.StringEqual('Yes')))

        # TODO only allow PKs and KEKs from known good vendors
        vd.set('61dfe48b-ca93-d211-aa0d-00e098032b8c', 'PK', tests.AcceptAll())
        vd.set('61dfe48b-ca93-d211-aa0d-00e098032b8c', 'KEK', tests.AcceptAll())
        vd.set('cbb219d7-3a3d-9645-a3bc-dad00e67656f', 'db', tests.AcceptAll())
        vd.set('cbb219d7-3a3d-9645-a3bc-dad00e67656f', 'dbx', tests.AcceptAll())

        # Test for validating the applications that are loaded in UEFI
        tt = [tests.DigestTest(refstate["boot"]["bootx64.efi"]),
              tests.DigestTest(refstate["boot"]["grubx64.efi"]),
              tests.DigestTest(refstate["boot"]["vmlinuz"])]
        bsa_test = tests.TupleTest(*tt)



        events_final = tests.DelayToFields(
            tests.FieldsTest(
                bsas=bsa_test,

                ),
            'bsas')


        # A list of allowed digests for firmware from device driver appears
        # in PCR2, event type EV_EFI_BOOT_SERVICES_DRIVER. Here we will just
        # accept everything
        dispatcher.set((2, 'EV_EFI_BOOT_SERVICES_DRIVER'),
                       tests.AcceptAll())

        # Accept all boot order entries
        dispatcher.set((1, 'EV_EFI_VARIABLE_BOOT'), tests.VariableTest(
            '61dfe48b-ca93-d211-aa0d-00e098032b8c',
            re.compile('BootOrder|Boot[0-9a-fA-F]+'),
            tests.AcceptAll()))

        # EV_EFI_ACTION and EV_SEPARATOR do not any meaningful information
        dispatcher.set((4, 'EV_EFI_ACTION'), tests.AcceptAll())
        for pcr in range(8):
            dispatcher.set((pcr, 'EV_SEPARATOR'), tests.AcceptAll())

        # Ignore all GPT related events
        dispatcher.set((5, 'EV_EFI_GPT_EVENT'), tests.AcceptAll())

        # Ignore shim CA and sbat entries. We already checked if it is the correct binary
        dispatcher.set((7, 'EV_EFI_VARIABLE_AUTHORITY'), tests.AcceptAll())


        # Validate that only the correct shim, grub and kernel was used
        dispatcher.set((4, 'EV_EFI_BOOT_SERVICES_APPLICATION'),
                       events_final.get('bsas'))

        # Ignore Mok DB entries generated by the shim
        dispatcher.set((14, 'EV_IPL'), tests.AcceptAll())

        # Verify files loaded by Grub
        grub_tests = []
        for name, digest in refstate["grub_files"].items():
            test = tests.And(
                tests.DigestTest(digest),
                tests.FieldTest('Event', tests.FieldTest('String', tests.RegExp(f".*{name}")))
            )
            grub_tests.append(test)

        # Check if the measured vmlinuz and initrd from Grub matches our expected values
        vmlinuz = tests.FieldTest('Event', tests.FieldTest('String', tests.RegExp(f"/live/vmlinuz")))
        initrd = tests.FieldTest('Event', tests.FieldTest('String', tests.RegExp(f"/live/initrd.img")))

        dispatcher.set((9, 'EV_IPL'), tests.Or(*grub_tests, vmlinuz, initrd))

        # Allow all Grub commands to be run and validate the kernel cmd-line
        dispatcher.set((8, 'EV_IPL'), tests.FieldTest('Event', tests.FieldTest('String', tests.Or(
            tests.RegExp('grub_cmd: .*', re.DOTALL),
            tests.And(
                tests.RegExp('kernel_cmdline: .*'))
                # TODO check for actual valid regex!
        ))))

        dispatcher.set((5, 'EV_EFI_ACTION'), tests.AcceptAll())

        events_test = tests.FieldTest('events',
                                      tests.And(
                                          events_final.get_initializer(),
                                          tests.IterateTest(
                                              dispatcher, show_elt=True),
                                          events_final),
                                      show_name=False)
        return events_test


policies.register('lernstick', LernstickPolicy())

